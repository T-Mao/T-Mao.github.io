---
layout: post
title: What I Learned from “Infrastructure as Code - The Big Picture”
date: 2025-08-10 09:00:00
description: Detailed notes and reflections on IaC concepts, risks, benefits, tool selection, and the DevOps fit, based on Eugene Meidinger’s course.
tags: [devops, iac, terraform, cloud, automation, sre]
categories: devops
thumbnail: https://images.unsplash.com/photo-1498050108023-c5249f4df085?q=80\&w=1200\&auto=format\&fit=crop
pretty_table: true
---

<div class="row">
  <div class="col-sm mt-3 mt-md-0 text-center">
    {% include figure.liquid
       loading="eager"
       path="https://images.unsplash.com/photo-1498050108023-c5249f4df085?q=80&w=1200&auto=format&fit=crop"
       title="Infrastructure as Code"
       class="rounded z-depth-1"
       max-width="900px"
    %}
  </div>
</div>

> I completed **“Infrastructure as Code: The Big Picture”** by **Eugene Meidinger**. This post documents the course content and adds my own reflections from mobile and backend development work.

---

## 0 · Scope

The course explains Infrastructure as Code at a conceptual level. It focuses on:

1. why manual infrastructure changes are risky,
2. what IaC is and the benefits it provides,
3. how to select and reason about tools, including declarative versus imperative approaches and idempotence,
4. how IaC relates to DevOps and how each practice strengthens the other.

---

## 1 · What Infrastructure as Code Is

**Definition**: describe the desired end state of infrastructure in code, then use a tool to converge the runtime to that state. The emphasis is on repeatability, reviewability, and control.

**Core properties**

- **Declarative thinking**: describe what the environment should look like.
- **Idempotence**: repeated runs lead to the same outcome.
- **State awareness**: the system compares current state with desired state and plans changes.
- **Drift control**: detect and correct divergence between reality and code.

---

## 2 · Why Manual Changes Are Risky

The course uses a simple scenario: an older server that needs security tweaks. The real risks are not the commands but everything around them.

| Risk                | Why it happens                              | Result                                       |
| :------------------ | :------------------------------------------ | :------------------------------------------- |
| No reproducibility  | One-off console clicks and tribal knowledge | Work cannot be repeated with confidence      |
| Hidden coupling     | Environment differences remain undocumented | Staging and production behave differently    |
| Missing audit trail | Changes are not reviewed or recorded        | Ownership and accountability are unclear     |
| Configuration drift | Console edits accumulate over time          | Code and reality diverge and debugging slows |

**Lesson**: teams often avoid change because change feels dangerous. IaC reduces the danger by making changes explicit, reviewable, and repeatable.

---

## 3 · Benefits of IaC

The course separates benefits into two groups.

**Inherent benefits**

- Reproducible environments that can be rebuilt quickly
- Versioned and reviewable changes through source control
- Self-documenting configuration that explains intent
- A safer path to small, frequent updates

**What IaC unlocks**

- **Better collaboration**: peers can read and review plans as code
- **Automation**: integration with CI to validate and apply changes
- **Faster recovery**: hotfixes and environment recreation become tractable
- **Alignment with modern delivery**: infrastructure moves at the same cadence as application code

---

## 4 · Picking an IaC Tool

The course proposes a simple framework to narrow choices.

| Question                               | Implication                                                                                                                     |
| :------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------ |
| **Where does the infrastructure live** | Cloud-specific tools are natural starting points if you stay in one provider. Multi-cloud favors cross-provider tools.          |
| **Provision or configure**             | Some tools excel at **provisioning** resources. Others focus on **configuration management** inside hosts.                      |
| **How will changes be expressed**      | **Declarative** tools describe end state. **Imperative** tools list steps. Understanding this tradeoff clarifies failure modes. |

**Key concepts clarified**

- **Declarative vs imperative**: outcome versus steps
- **Idempotence**: safe to run repeatedly
- **Drift**: detect and correct divergence from code

---

## 5 · IaC and DevOps

**How IaC benefits DevOps**

- Shared artifacts for review and discussion
- Consistent, repeatable deployments that support higher release frequency
- Easier environment reproduction for testing and hotfixes

**How DevOps benefits IaC**

- Source control and code review create a reliable change process
- Continuous integration surfaces errors earlier
- Testing practices can validate infrastructure behavior, not just syntax

---

## 6 · My Reflections and Examples

These are situations I have encountered in mobile and backend work. The course helped me frame why they felt hard and how an IaC mindset would have improved outcomes.

### 6.1 Positive pattern: small, reviewable changes

- **Context**: frequent application releases required updates to environment variables and third-party service settings.
- **What worked**: when configuration lived alongside code and changes were reviewed in pull requests, rollouts were calm and reversible.
- **Course tie-in**: treat infrastructure as a versioned artifact. Small, reviewed changes reduce risk and speed recovery.

### 6.2 Negative pattern: console-only configuration

- **Context**: a service depended on storage permissions and CORS rules that were adjusted in the console during a time-pressured fix.
- **What went wrong**: the change was not captured anywhere, so staging and production drifted. A later deployment broke uploads and diagnosis took hours.
- **Course tie-in**: this is classic configuration drift. IaC would have made the change visible as code and repeatable across environments.

### 6.3 Positive pattern: shared language between dev and ops

- **Context**: developers and infrastructure owners discussed capacity, networking, and secrets as code comments and variables instead of screenshots.
- **Impact**: onboarding sped up, because new teammates could read configuration and propose improvements.
- **Course tie-in**: collaboration improves when plans are code, not prose.

### 6.4 Negative pattern: unclear rollback

- **Context**: a fix required multiple manual steps that no one wanted to repeat under pressure.
- **Impact**: the safest option became “do nothing,” which slowed delivery and left technical debt in place.
- **Course tie-in**: idempotent operations and state awareness make rollback a routine operation instead of an ad hoc decision.

---

## 7 · What I Will Apply First

1. Prefer declarative definitions for environments that change frequently.
2. Treat source control and code review as the default for infrastructure changes.
3. Document assumptions as code comments near variables and modules.
4. Schedule regular plan or diff checks to detect drift early.
5. Keep changes small so rollback is practical.
