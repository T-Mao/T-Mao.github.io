<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <div class="row"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/threetodo-480.webp 480w,/assets/img/threetodo-800.webp 800w,/assets/img/threetodo-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/threetodo.png" class="rounded z-depth-0" width="100%" height="auto" style=" max-width: 300px; " title="ThreeTodo App" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <h2 id="overview">Overview</h2> <p>From <strong>April 13 to April 21, 2024</strong>, I independently built <strong>ThreeTodo</strong>, a <strong>lightweight iOS</strong> task manager emphasizing <strong>fluid navigation</strong>, <strong>minimal UI</strong>, and <strong>drag-and-drop</strong> efficiency. The project demanded a <strong>swift</strong>, <strong>five-day</strong> turnaround—an ideal environment to showcase my <strong>agile</strong> approach and expertise in <strong>user-centric</strong> design. ThreeTodo’s hallmark is its <strong>intuitive</strong> multi-page structure (Plan / Today / Thoughts), requiring minimal taps or screens to keep track of evolving tasks and ideas.</p> <p><br></p> <h2 id="core-highlights">Core Highlights</h2> <ol> <li> <p><strong>Rapid Development</strong></p> <ul> <li>Single-handedly coded and tested within just <strong>five days</strong>, from initial concept to functional MVP.</li> <li>Utilized <strong>SwiftUI</strong> for swift prototyping, iterative feedback, and <strong>clean</strong> layout definitions.</li> </ul> </li> <li> <p><strong>Minimal Navigation &amp; UI</strong></p> <ul> <li>Only <strong>three</strong> primary views—<strong>Plan</strong>, <strong>Today</strong>, and <strong>Thoughts</strong>—to reduce complexity.</li> <li>Implemented <strong>drag-and-drop</strong> gestures for reordering tasks, cross-screen transfers, and quick deletion in a single <strong>touch</strong> flow.</li> <li>No extraneous steps (due dates, priority setups)—<strong>one-tap</strong> additions or inline edits.</li> </ul> </li> <li> <p><strong>User-centric Approach</strong></p> <ul> <li>Emphasis on <strong>inline editing</strong> with dynamic text expansions (auto height), eliminating sub-menus or separate edit screens.</li> <li> <strong>Contextual actions</strong>: hold long-press to insert dividers, multi-task deletion, or use a built-in “trash” drop zone.</li> </ul> </li> <li> <p><strong>Agile Success &amp; Feedback</strong></p> <ul> <li>Deployed an MVP that testers praised for <strong>clarity</strong> and <strong>practical</strong> usage in daily to-do management.</li> <li>Demonstrated readiness for <strong>quick project</strong> turnarounds in dynamic, fast-paced environments.</li> </ul> </li> </ol> <p><br></p> <h2 id="key-functionalities">Key Functionalities</h2> <h3 id="1-draggable-tasks--cross-screen-flows">1. Draggable Tasks &amp; Cross-Screen Flows</h3> <ul> <li> <p><strong>Single Source of Truth</strong>:</p> <ul> <li>Maintained tasks in three arrays (<code class="language-plaintext highlighter-rouge">plans</code>, <code class="language-plaintext highlighter-rouge">todays</code>, <code class="language-plaintext highlighter-rouge">thoughts</code>) with a global function <code class="language-plaintext highlighter-rouge">removeTaskGlobally()</code> to seamlessly move a task from one screen to another if dragged outside.</li> </ul> </li> <li> <p><strong>Swipe-based Navigation</strong>:</p> <ul> <li> <strong>SwiftUI TabView</strong> with <code class="language-plaintext highlighter-rouge">.page</code> style—<strong>Plan</strong>, <strong>Today</strong>, <strong>Thoughts</strong>—enables horizontal swiping.</li> <li>Each tab maintains its own list of tasks, but a user can drag tasks from one list onto another tab’s “plus” button to re-categorize.</li> </ul> </li> </ul> <details> <summary><strong>Sample: Drag &amp; Drop for Cross-Screen Transfer</strong></summary> <figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">handleDropTask</span><span class="p">(</span><span class="n">withId</span> <span class="nv">taskId</span><span class="p">:</span> <span class="kt">UUID</span><span class="p">)</span> <span class="p">{</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">task</span> <span class="o">=</span> <span class="nf">removeTaskGlobally</span><span class="p">(</span><span class="n">taskId</span><span class="p">)</span> <span class="p">{</span>
<span class="n">tasks</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
<span class="p">}</span>
<span class="p">}</span></code></pre></figure> **Why it’s clever**: - Relies on a universal `removeTaskGlobally()` to detach a `TaskItem` from whichever array it’s in, then appends it to the **destination** array. - Minimizes user steps: a single drag gesture reassigns tasks across categories. </details> <p><br></p> <h3 id="2-inline-editing--resizable-text-fields">2. Inline Editing &amp; Resizable Text Fields</h3> <ul> <li> <p><strong>Dynamic TextEditor</strong>:</p> <ul> <li>Each task dynamically resizes based on content length.</li> <li>No separate “edit mode”; text is always directly editable in place.</li> </ul> </li> <li> <p><strong>Height Estimation</strong>:</p> <ul> <li>Calculated text height using <code class="language-plaintext highlighter-rouge">NSLayoutManager</code> and <code class="language-plaintext highlighter-rouge">NSTextContainer</code> to ensure the UI expansions remain fluid and stable.</li> </ul> </li> </ul> <details> <summary><strong>Sample: Dynamic Sizing for Task Text</strong></summary> <figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">private</span> <span class="kd">func</span> <span class="nf">estimateHeight</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">width</span><span class="p">:</span> <span class="kt">CGFloat</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">CGFloat</span> <span class="p">{</span>
<span class="k">let</span> <span class="nv">attributes</span><span class="p">:</span> <span class="p">[</span><span class="kt">NSAttributedString</span><span class="o">.</span><span class="kt">Key</span><span class="p">:</span> <span class="kt">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
<span class="o">.</span><span class="nv">font</span><span class="p">:</span> <span class="kt">UIFont</span><span class="o">.</span><span class="nf">systemFont</span><span class="p">(</span><span class="nv">ofSize</span><span class="p">:</span> <span class="n">fontSize</span><span class="p">)</span>
<span class="p">]</span>
<span class="k">let</span> <span class="nv">textStorage</span> <span class="o">=</span> <span class="kt">NSTextStorage</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="n">text</span><span class="p">,</span> <span class="nv">attributes</span><span class="p">:</span> <span class="n">attributes</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">textContainer</span> <span class="o">=</span> <span class="kt">NSTextContainer</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="kt">CGSize</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">30</span><span class="p">,</span>
<span class="nv">height</span><span class="p">:</span> <span class="o">.</span><span class="n">greatestFiniteMagnitude</span><span class="p">))</span>
<span class="k">let</span> <span class="nv">layoutManager</span> <span class="o">=</span> <span class="kt">NSLayoutManager</span><span class="p">()</span>
<span class="n">layoutManager</span><span class="o">.</span><span class="nf">addTextContainer</span><span class="p">(</span><span class="n">textContainer</span><span class="p">)</span>
<span class="n">textStorage</span><span class="o">.</span><span class="nf">addLayoutManager</span><span class="p">(</span><span class="n">layoutManager</span><span class="p">)</span>

    <span class="n">layoutManager</span><span class="o">.</span><span class="nf">glyphRange</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">textContainer</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">rect</span> <span class="o">=</span> <span class="n">layoutManager</span><span class="o">.</span><span class="nf">usedRect</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">textContainer</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">ceil</span><span class="p">(</span><span class="n">rect</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>

<span class="p">}</span></code></pre></figure> **Why it’s clever**: - Merges SwiftUI’s real-time rendering with a refined height calculation from UIKit’s text system. - Ensures tasks seamlessly expand while maintaining a stable list layout. </details> <p><br></p> <h3 id="3-contextual-menus--divider-templates">3. Contextual Menus &amp; Divider Templates</h3> <ul> <li> <p><strong>Dividers</strong>:</p> <ul> <li>Long-press on the “+” button toggles between adding normal tasks or <strong>divider</strong> tasks.</li> <li>Dividers help visually group tasks—<strong>Morning / Afternoon / Evening</strong>, or custom user-defined sets.</li> </ul> </li> <li> <p><strong>Template System</strong>:</p> <ul> <li>Users can create an array of divider sets (<code class="language-plaintext highlighter-rouge">["Morning", "Afternoon", "Evening"]</code> etc.) and insert them as needed.</li> <li>Efficiently reuses repeated structures for daily planning or priority grouping.</li> </ul> </li> </ul> <details> <summary><strong>Sample: TemplateSelector &amp; Inline Generation</strong></summary> <figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kt">TemplateSelector</span><span class="p">(</span><span class="nv">templates</span><span class="p">:</span> <span class="n">$templates</span><span class="p">)</span> <span class="p">{</span> <span class="n">selectedTemplate</span> <span class="k">in</span>
<span class="k">for</span> <span class="n">name</span> <span class="k">in</span> <span class="n">selectedTemplate</span><span class="o">.</span><span class="n">names</span> <span class="p">{</span>
<span class="n">tasks</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="kt">TaskItem</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="nv">isDivider</span><span class="p">:</span> <span class="kc">true</span><span class="p">))</span>
<span class="p">}</span>
<span class="p">}</span></code></pre></figure> **Why it’s clever**: - Lowers repetitive setup each day by letting users inject full sets of custom dividers with **one tap**. - Showcases swift prototyping: the entire logic is built as a separate reusable SwiftUI `View`. </details> <p><br></p> <h3 id="4-swift--swiftui-architecture">4. Swift &amp; SwiftUI Architecture</h3> <ul> <li> <strong>Single <code class="language-plaintext highlighter-rouge">ContentView</code></strong>: orchestrates data arrays for three subviews (Plan, Today, Thoughts).</li> <li> <p><strong>Per-Tab</strong> custom <code class="language-plaintext highlighter-rouge">TodoListView</code>**:</p> <ul> <li>Each view includes a “trash” area for convenient mass deletion or single drag-drop disposal.</li> <li>Each list uses SwiftUI’s <code class="language-plaintext highlighter-rouge">List</code> with <code class="language-plaintext highlighter-rouge">.onMove(perform:)</code> to reorder tasks seamlessly.</li> </ul> </li> <li> <strong>UserDefaults Persistence</strong>: <ul> <li>Data is periodically encoded via <code class="language-plaintext highlighter-rouge">JSONEncoder</code> for quick, simple local storage.</li> </ul> </li> </ul> <details> <summary><strong>Sample: Multi-Tab &amp; Data Persistence</strong></summary> <figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">saveData</span><span class="p">()</span> <span class="p">{</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">encodedPlans</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="kt">JSONEncoder</span><span class="p">()</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">plans</span><span class="p">),</span>
<span class="k">let</span> <span class="nv">encodedTodays</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="kt">JSONEncoder</span><span class="p">()</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">todays</span><span class="p">),</span>
<span class="k">let</span> <span class="nv">encodedThoughts</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="kt">JSONEncoder</span><span class="p">()</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">thoughts</span><span class="p">)</span> <span class="p">{</span>
<span class="kt">UserDefaults</span><span class="o">.</span><span class="n">standard</span><span class="o">.</span><span class="nf">set</span><span class="p">(</span><span class="n">encodedPlans</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="s">"Plans"</span><span class="p">)</span>
<span class="kt">UserDefaults</span><span class="o">.</span><span class="n">standard</span><span class="o">.</span><span class="nf">set</span><span class="p">(</span><span class="n">encodedTodays</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="s">"Todays"</span><span class="p">)</span>
<span class="kt">UserDefaults</span><span class="o">.</span><span class="n">standard</span><span class="o">.</span><span class="nf">set</span><span class="p">(</span><span class="n">encodedThoughts</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="s">"Thoughts"</span><span class="p">)</span>
<span class="p">}</span>
<span class="p">}</span></code></pre></figure> **Why it’s clever**: - Merges the entire multi-view model into straightforward JSON for minimal overhead. - Ensures tasks are automatically recovered upon relaunch without complex external databases. </details> <p><br></p> <h2 id="project-outcomes">Project Outcomes</h2> <ul> <li> <strong>Immediate Praise</strong>: Beta testers found the app’s simplicity extremely appealing—<strong>“No fluff, just tasks.”</strong> </li> <li> <strong>Demonstrated Agility</strong>: Showed that a <strong>week-long</strong> project can produce a highly functional, user-friendly to-do manager with advanced features (drag, context menus, partial screen transfers).</li> <li> <strong>Scalable</strong>: The approach can easily integrate additional boards/screens or more advanced collaborative features—foundation is deliberately <strong>clean</strong> and easily extensible.</li> </ul> <p><br></p> <h2 id="personal-growth--reflection">Personal Growth &amp; Reflection</h2> <ol> <li> <p><strong>Technical Mastery</strong></p> <ul> <li>Mastered bridging advanced iOS text measurement (<code class="language-plaintext highlighter-rouge">NSLayoutManager</code>) with SwiftUI’s reactive layout.</li> <li>Fine-tuned multi-gesture logic for a truly drag-centric UX, from in-list reordering to cross-list moves.</li> </ul> </li> <li> <p><strong>Rapid Delivery &amp; Problem-Solving</strong></p> <ul> <li>Balanced “must-have” features (inline editing, drag-and-drop) with a minimal UI to meet a <strong>five-day</strong> MVP deadline.</li> <li>Employed iterative refinements—<strong>shipping</strong> quickly and refining on user feedback in real time.</li> </ul> </li> <li> <p><strong>User-Centered Design</strong></p> <ul> <li>Avoided common complexities like due dates or priorities, focusing on frictionless daily usage.</li> <li>Keenly leveraged “divider” logic and templates to reduce repetitive overhead and highlight user creativity.</li> </ul> </li> </ol> <p><br></p> <h2 id="final-thoughts">Final Thoughts</h2> <p><strong>ThreeTodo</strong> exemplifies my ability to craft a <strong>purpose-driven</strong> app under tight deadlines, employing a lean feature set that resonates with everyday to-do needs. By championing straightforward user flows (dragging, minimal tapping) and implementing technical solutions (dynamic text expansion, flexible data structures, context menus), I delivered a tool that merges <strong>usability</strong>, <strong>performance</strong>, and <strong>clarity</strong>—all in under a week.</p> <p>This project underscores my competence in <strong>rapidly</strong> transforming an idea into a polished, robust product. It stands as proof of my <strong>coding versatility</strong> in Swift and my dedication to <strong>user-friendly</strong> software design that truly meets real-world demands.</p> </body></html>