<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://t-mao.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://t-mao.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-26T18:15:34+00:00</updated><id>https://t-mao.github.io/feed.xml</id><title type="html">blank</title><subtitle>Tongze Mao&apos;s personal folio website for academics. </subtitle><entry><title type="html">Harnessing RSA Encryption in Mobile Apps</title><link href="https://t-mao.github.io/blog/2025/RSA-Encryption/" rel="alternate" type="text/html" title="Harnessing RSA Encryption in Mobile Apps"/><published>2025-02-26T09:00:00+00:00</published><updated>2025-02-26T09:00:00+00:00</updated><id>https://t-mao.github.io/blog/2025/RSA-Encryption</id><content type="html" xml:base="https://t-mao.github.io/blog/2025/RSA-Encryption/"><![CDATA[<p>As modern applications handle increasingly sensitive data, robust security measures become paramount. One common, time-tested approach to safeguarding data is RSA encryption. Within the context of mobile app development, RSA proves invaluable for securing user credentials, passwords, or any piece of confidential data that traverses potentially insecure networks.</p> <h2 id="rsa-overview">RSA Overview</h2> <p>RSA (Rivest‚ÄìShamir‚ÄìAdleman) is an asymmetric cryptographic algorithm. Instead of relying on one shared key (as in symmetric encryption), it uses a pair of keys:</p> <ul> <li><strong>Public Key:</strong> Used for encryption. Typically shared with anyone who needs to send encrypted data.</li> <li><strong>Private Key:</strong> Used for decryption. Kept absolutely secure and never shared.</li> </ul> <p>The essential advantage in app development is that you can freely distribute your public key in your mobile application to encrypt user-submitted data (e.g., password fields during registration), while the private key (on your server or a secure service) safely decrypts incoming messages.</p> <h2 id="key-points-for-mobile-developers">Key Points for Mobile Developers</h2> <ol> <li><strong>Key Storage:</strong> The public key can be embedded into the app or fetched from a secure endpoint. The private key must remain on a secure server or hardware security module (HSM).</li> <li><strong>Performance Considerations:</strong> RSA encryption is computationally heavier than symmetric algorithms (like AES). Typically, developers use RSA to transmit session keys or sensitive short strings (like credentials), then switch to faster symmetric encryption for ongoing data exchange.</li> <li><strong>Security Best Practices:</strong> Always validate certificate chains, use well-maintained cryptographic libraries, keep libraries up-to-date, and follow platform security guidelines (e.g., Android Keystore, iOS Keychain).</li> </ol> <h2 id="practical-implementation">Practical Implementation</h2> <p>Below is a Dart-based example I developed focusing on an RSA-based encryption utility (<code class="language-plaintext highlighter-rouge">RsaEncrypt</code>). This snippet demonstrates encrypting plaintext (a password, for instance) using a public key. Once encrypted, the resulting ciphertext can safely traverse the network to the backend, where only the corresponding private key can decrypt it.</p> <div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="s">'dart:developer'</span><span class="o">;</span>
<span class="kn">import</span> <span class="s">'package:app_utils/utils/environments.dart'</span><span class="o">;</span>
<span class="kn">import</span> <span class="s">'package:encrypt/encrypt.dart'</span><span class="o">;</span>
<span class="kn">import</span> <span class="s">'package:pointycastle/asymmetric/api.dart'</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">RsaEncrypt</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kt">String</span> <span class="n">encryptString</span><span class="p">({</span><span class="kd">required</span> <span class="kt">String</span> <span class="n">plainText</span><span class="p">})</span> <span class="p">{</span>
    <span class="n">log</span><span class="p">(</span><span class="s">'üîê Starting RSA encryption...'</span><span class="p">);</span>
    <span class="kd">final</span> <span class="n">publicKey</span> <span class="o">=</span> <span class="n">_parsePublicKeyFromPem</span><span class="p">(</span><span class="n">Environments</span><span class="o">.</span><span class="na">getPublicKeyString</span><span class="p">());</span>
    <span class="n">log</span><span class="p">(</span><span class="s">'üîë Public key parsed successfully'</span><span class="p">);</span>
    <span class="kd">final</span> <span class="n">encryptedText</span> <span class="o">=</span> <span class="n">Encrypter</span><span class="p">(</span><span class="n">RSA</span><span class="p">(</span><span class="nl">publicKey:</span> <span class="n">publicKey</span><span class="p">))</span><span class="o">.</span><span class="na">encrypt</span><span class="p">(</span><span class="n">plainText</span><span class="p">);</span>
    <span class="n">log</span><span class="p">(</span><span class="s">'üîí Encryption complete'</span><span class="p">);</span>

    <span class="c1">// Debug prints</span>
    <span class="n">log</span><span class="p">(</span><span class="s">"______________Plaintext_________________"</span><span class="p">);</span>
    <span class="n">log</span><span class="p">(</span><span class="n">plainText</span><span class="p">);</span>
    <span class="n">log</span><span class="p">(</span><span class="s">"______________Plaintext End_________________"</span><span class="p">);</span>
    <span class="n">log</span><span class="p">(</span><span class="s">"______________Ciphertext_________________"</span><span class="p">);</span>
    <span class="n">log</span><span class="p">(</span><span class="n">encryptedText</span><span class="o">.</span><span class="na">base64</span><span class="p">);</span>
    <span class="n">log</span><span class="p">(</span><span class="s">"______________Ciphertext End_________________"</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">encryptedText</span><span class="o">.</span><span class="na">base64</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// Parse a public key from PEM format</span>
  <span class="kd">static</span> <span class="n">RSAPublicKey</span> <span class="n">_parsePublicKeyFromPem</span><span class="p">(</span><span class="kt">String</span> <span class="n">pemString</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">final</span> <span class="n">parser</span> <span class="o">=</span> <span class="n">RSAKeyParser</span><span class="p">();</span>
    <span class="kd">final</span> <span class="n">key</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="na">parse</span><span class="p">(</span><span class="n">pemString</span><span class="o">.</span><span class="na">trim</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">key</span> <span class="k">as</span> <span class="n">RSAPublicKey</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="example-flow-in-a-registration-screen">Example Flow in a Registration Screen</h3> <p>In one of my mobile apps, I integrated RSA into the user registration form. During the final ‚ÄúCreate Account‚Äù step:</p> <ol> <li><strong>Extract User Input</strong>: Collect the email, password, and other sensitive fields from text controllers.</li> <li><strong>Encrypt with RSA</strong>: Call the <code class="language-plaintext highlighter-rouge">encryptString()</code> method before sending them out to the API.</li> <li><strong>Transmit</strong>: Post the encrypted ciphertext to the server via HTTPS.</li> <li><strong>Server Decryption</strong>: The server (holding the private key) decrypts the data and proceeds with user creation.</li> </ol> <p>Below is a simplified excerpt of a Flutter widget illustrating how RSA encryption might slot into a password-handling flow:</p> <div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Simplified snippet from CreateAccountPageWidget</span>
<span class="kt">String</span> <span class="n">encryptedPassword</span> <span class="o">=</span> <span class="n">RsaEncrypt</span><span class="o">.</span><span class="na">encryptString</span><span class="p">(</span>
  <span class="nl">plainText:</span> <span class="n">_model</span><span class="o">.</span><span class="na">passwordTextController</span><span class="o">.</span><span class="na">text</span><span class="p">,</span>
<span class="p">);</span>

<span class="c1">// Send to server using an authenticated endpoint</span>
<span class="kd">final</span> <span class="n">userRegisterData</span> <span class="o">=</span> <span class="k">await</span> <span class="n">ApiAuth</span><span class="o">.</span><span class="na">api</span><span class="o">.</span><span class="na">userRegister</span><span class="p">(</span>
  <span class="nl">email:</span> <span class="n">_model</span><span class="o">.</span><span class="na">emailTextController</span><span class="o">.</span><span class="na">text</span><span class="p">,</span>
  <span class="nl">password:</span> <span class="n">encryptedPassword</span><span class="p">,</span>
  <span class="c1">// ...</span>
<span class="p">);</span>
</code></pre></div></div> <p>Using RSA for this crucial step helps ensure that a user‚Äôs password or other sensitive information is never sent as raw plaintext. While HTTPS adds transport-layer security, layering RSA can add an additional control or help meet certain compliance scenarios where end-to-end encryption is mandated.</p> <h2 id="additional-tips">Additional Tips</h2> <ol> <li><strong>Use Trusted Libraries</strong>: Handling cryptography manually is risky. Established libraries such as <code class="language-plaintext highlighter-rouge">encrypt</code> (Dart), OpenSSL (C/C++), or platform-specific APIs (Android‚Äôs <code class="language-plaintext highlighter-rouge">Cipher</code>, iOS‚Äôs <code class="language-plaintext highlighter-rouge">SecKey</code>) reduce risk and handle behind-the-scenes complexities.</li> <li><strong>Size Limitations</strong>: RSA encrypts data in chunks. Keep the plaintext size relatively small or implement a hybrid approach (RSA to protect an AES key, then AES for bulk encryption).</li> <li><strong>Logging</strong>: Notice the debug logs above‚Äîthough useful for development, they must be removed or redacted in production environments to avoid leaking sensitive info.</li> </ol> <h2 id="conclusion">Conclusion</h2> <p>Implementing RSA in your mobile application can raise the security bar significantly, especially for user onboarding flows, login credentials, and other delicate transactions. My approach involves carefully parsing a PEM-encoded public key, encrypting short strings client-side, and ensuring the corresponding decryption is handled by a protected private key on the backend.</p> <p>In app development contexts, adopting robust cryptographic primitives like RSA indicates a refined understanding of security‚Äîsomething potential employers and clients appreciate. Coupled with efficient coding patterns and best-practice key management, this method protects user information against prying eyes throughout the data‚Äôs journey.</p>]]></content><author><name></name></author><category term="mobile-encryption"/><category term="security"/><category term="cryptography"/><category term="rsa"/><summary type="html"><![CDATA[A closer look at RSA cryptography and its practical implementation in app development]]></summary></entry></feed>